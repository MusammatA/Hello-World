<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <title>Brain Rot Central</title>
  
   <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
   <link rel="preconnect" href="https://fonts.googleapis.com">
   <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
   <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500;600;700&family=JetBrains+Mono:wght@600;700;800&display=swap" rel="stylesheet">
   <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
   <link rel="stylesheet" href="styles.css">
</head>
<body>
   <aside class="sidebar" id="sidebar" style="display:none;">
      <div class="sidebar-title">Modes</div>
      <button id="tab-grid" class="side-tab active" onclick="switchView('grid')">
         <i class="fa-solid fa-table-cells-large"></i> Gallery
      </button>
      <button id="tab-swipe" class="side-tab" onclick="switchView('swipe')">
         <i class="fa-solid fa-hand-pointer"></i> Quick Vote
      </button>
      <button id="tab-upload" class="side-tab" onclick="switchView('upload')">
         <i class="fa-solid fa-upload"></i> Create
      </button>
      <button id="tab-account" class="side-tab" onclick="switchView('account')">
         <i class="fa-solid fa-user-gear"></i> Account
      </button>
      <button id="tab-discover" class="side-tab" onclick="switchView('discover')">
         <i class="fa-solid fa-user-group"></i> Find Users
      </button>
      <button id="tab-communities" class="side-tab" onclick="switchView('communities')">
         <i class="fa-solid fa-users"></i> Communities
      </button>
   </aside>

   <div class="container">
       <h1>Brain Rot Central</h1>
       <p class="subtitle">Caption chaos, professionally organized.</p>

       <div class="search-wrapper" style="display: none;">
           <input type="text" id="search-input" placeholder="Find a caption worth stealing...">
       </div>

       <div id="content-view">
           <p class="loading-copy" style="text-align: center;">Warming up the meme engine...</p>
       </div>
   </div>

   <div id="click-logger" style="position: fixed; bottom: 0; left: 0; width: 100%; height: 100px; background: #222; color: #f0f0f0; font-family: monospace; font-size: 11px; overflow-y: scroll; padding: 10px; border-top: 2px solid #444; z-index: 9999; display: none;">
       <div id="log-content"></div>
   </div>

   <script>
       const SUPABASE_URL = 'https://secure.almostcrackd.ai'
       const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InFpaHNnbmZqcW1ram1vb3d5ZmJuIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDk1Mjc0MDAsImV4cCI6MjA2NTEwMzQwMH0.c9UQS_o2bRygKOEdnuRx7x7PeSf_OUGDtf9l3fMqMSQ'
      
       let supabaseClient;
       let allMemes = [];
       let voteStats = {};
       let CURRENT_USER_ID = null;
       let CURRENT_ACCESS_TOKEN = null;
       let CURRENT_USER_EMAIL = '';
       let CURRENT_UPLOADER_NAME = '';
       let currentView = 'grid';
       let swipeIndex = 0;
       let swipeHistory = [];
       let currentSearchTerm = '';
       let generatedMemes = [];
       let imageUrlById = {};
       let AUTO_REFRESH_TIMER = null;
       let REALTIME_CHANNEL = null;
       let REALTIME_REFRESH_TIMER = null;
       let FEED_FETCH_IN_FLIGHT = false;
       let FEED_FETCH_QUEUED = false;
       let ACCOUNT_ACTION_MESSAGE = '';
       let uploaderSearchTerm = '';
       let communities = ['General'];
       let selectedCommunityName = 'General';
       let communityCreateMessage = '';
       let communityUploadStatus = '';
       let communityByCaptionId = {};
       let communityByImageId = {};
       let IS_PHONE_CLIENT = false;
       let UPLOAD_IN_FLIGHT = false;
       let LAST_UPLOAD_AT = 0;
       let VISIBILITY_HOOK_SET = false;
       const VOTE_COOLDOWNS = {};
       let GENERATION_UI_STATE = {
           status: 'idle',
           modelTag: 'caption-pipeline-v1',
           message: 'Waiting for a new upload',
           updatedAtUtc: null
       };
       const SWIPE_PROGRESS_KEY_PREFIX = 'swipe_progress_v1_';
       const GENERATED_MEMES_KEY_PREFIX = 'generated_memes_v1_';
       const COMMUNITIES_KEY_PREFIX = 'communities_v1_';
       const COMMUNITY_MAP_KEY_PREFIX = 'community_map_v1_';
       const PIPELINE_BASE_URL = 'https://api.almostcrackd.ai';
       const PHONE_MEDIA_QUERY = '(max-width: 900px)';
       const FEED_REFRESH_MS = 30000;
       const MAX_UPLOAD_BYTES = 10 * 1024 * 1024;
       const UPLOAD_COOLDOWN_MS = 2500;
       const VOTE_COOLDOWN_MS = 450;
       const SUPPORTED_IMAGE_TYPES = new Set([
           'image/jpeg',
           'image/jpg',
           'image/png',
           'image/webp',
           'image/gif',
           'image/heic'
       ]);

       function getClient() {
           if (!supabaseClient) {
               supabaseClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY)
           }
           return supabaseClient;
       }

       function escapeHtml(value) {
           return String(value ?? '')
               .replace(/&/g, '&amp;')
               .replace(/</g, '&lt;')
               .replace(/>/g, '&gt;')
               .replace(/"/g, '&quot;')
               .replace(/'/g, '&#39;');
       }

       function safePreviewText(value, max = 180) {
           const text = String(value ?? '').trim();
           return escapeHtml(text.length > max ? `${text.slice(0, max)}...` : text);
       }

       function safeUrl(url, fallback) {
           const candidate = String(url || '').trim();
           if (!candidate) return fallback;
           if (candidate.startsWith('https://') || candidate.startsWith('http://')) return candidate;
           return fallback;
       }

       function toTitleCase(value) {
           return String(value || '')
               .split(' ')
               .filter(Boolean)
               .map(part => part.charAt(0).toUpperCase() + part.slice(1))
               .join(' ');
       }

       function deriveUploaderNameFromEmail(email) {
           if (!email) return 'Unknown uploader';
           const local = String(email).split('@')[0] || '';
           const spaced = local.replace(/[._-]+/g, ' ').trim();
           return toTitleCase(spaced || email);
       }

       function setCurrentUserIdentity(user) {
           CURRENT_USER_EMAIL = user?.email || '';
           CURRENT_UPLOADER_NAME = deriveUploaderNameFromEmail(CURRENT_USER_EMAIL);
       }

       function normalizeCommunityName(name) {
           return String(name || '').replace(/\s+/g, ' ').trim().slice(0, 48);
       }

       function getCommunitiesKey() {
           return CURRENT_USER_ID ? `${COMMUNITIES_KEY_PREFIX}${CURRENT_USER_ID}` : null;
       }

       function getCommunityMapKey() {
           return CURRENT_USER_ID ? `${COMMUNITY_MAP_KEY_PREFIX}${CURRENT_USER_ID}` : null;
       }

       function saveCommunityState() {
           const communitiesKey = getCommunitiesKey();
           const mapKey = getCommunityMapKey();
           if (!communitiesKey || !mapKey) return;
           try {
               localStorage.setItem(communitiesKey, JSON.stringify(Array.from(new Set(communities))));
               localStorage.setItem(mapKey, JSON.stringify({
                   byCaptionId: communityByCaptionId,
                   byImageId: communityByImageId
               }));
           } catch (_err) {}
       }

       function ensureCommunityExists(name) {
           const clean = normalizeCommunityName(name);
           if (!clean) return 'General';
           if (!communities.includes(clean)) {
               communities = ['General', ...communities.filter(c => c !== 'General'), clean].filter((v, i, arr) => arr.indexOf(v) === i);
           }
           return clean;
       }

       function loadCommunityState() {
           communities = ['General'];
           communityByCaptionId = {};
           communityByImageId = {};

           const communitiesKey = getCommunitiesKey();
           const mapKey = getCommunityMapKey();
           if (!communitiesKey || !mapKey) return;
           try {
               const communitiesRaw = localStorage.getItem(communitiesKey);
               if (communitiesRaw) {
                   const parsed = JSON.parse(communitiesRaw);
                   if (Array.isArray(parsed) && parsed.length) {
                       communities = ['General', ...parsed.map(normalizeCommunityName).filter(Boolean)].filter((v, i, arr) => arr.indexOf(v) === i);
                   }
               }
           } catch (_err) {}
           try {
               const mapRaw = localStorage.getItem(mapKey);
               if (mapRaw) {
                   const parsed = JSON.parse(mapRaw);
                   communityByCaptionId = parsed?.byCaptionId && typeof parsed.byCaptionId === 'object' ? parsed.byCaptionId : {};
                   communityByImageId = parsed?.byImageId && typeof parsed.byImageId === 'object' ? parsed.byImageId : {};
               }
           } catch (_err) {}

           selectedCommunityName = ensureCommunityExists(selectedCommunityName || 'General');
       }

       async function hydrateCommunitiesFromProfile(user) {
           try {
               const profileCommunities = Array.isArray(user?.user_metadata?.communities)
                   ? user.user_metadata.communities.map(normalizeCommunityName).filter(Boolean)
                   : [];
               if (!profileCommunities.length) return;
               communities = ['General', ...communities, ...profileCommunities]
                   .map(normalizeCommunityName)
                   .filter(Boolean)
                   .filter((v, i, arr) => arr.indexOf(v) === i);
               selectedCommunityName = ensureCommunityExists(selectedCommunityName || 'General');
               saveCommunityState();
           } catch (_err) {}
       }

       async function syncCommunitiesToProfile() {
           if (!CURRENT_USER_ID) return;
           try {
               const client = getClient();
               const target = Array.from(new Set((communities || []).map(normalizeCommunityName).filter(Boolean)));
               const { data: { user }, error } = await client.auth.getUser();
               if (error || !user) return;
               const existing = Array.isArray(user.user_metadata?.communities)
                   ? user.user_metadata.communities.map(normalizeCommunityName).filter(Boolean)
                   : [];
               const sameLength = existing.length === target.length;
               const sameItems = sameLength && existing.every((item, idx) => item === target[idx]);
               if (sameItems) return;
               await client.auth.updateUser({
                   data: {
                       ...(user.user_metadata || {}),
                       communities: target
                   }
               });
           } catch (err) {
               console.warn('[Communities] profile sync failed', err);
           }
       }

       function getMemeCommunity(item) {
           if (!item) return 'General';
           return item.communityName
               || (item.id ? communityByCaptionId[item.id] : '')
               || (item.image_id ? communityByImageId[item.image_id] : '')
               || 'General';
       }

       function applyCommunityMetadata(memes) {
           return (Array.isArray(memes) ? memes : []).map(item => ({
               ...item,
               communityName: getMemeCommunity(item)
           }));
       }

       function formatShortTime(isoString) {
           if (!isoString) return 'n/a';
           const date = new Date(isoString);
           if (Number.isNaN(date.getTime())) return 'n/a';
           return date.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' });
       }

       function extractModelTag(step4Data) {
           if (!step4Data || typeof step4Data !== 'object') return 'caption-pipeline-v1';
           return step4Data.model || step4Data.modelTag || step4Data.model_name || step4Data.generator || 'caption-pipeline-v1';
       }

       function setGenerationUIState(patch) {
           GENERATION_UI_STATE = {
               ...GENERATION_UI_STATE,
               ...patch,
               updatedAtUtc: new Date().toISOString()
           };
           paintGenerationUIState();
       }

       function paintGenerationUIState() {
           const statusEl = document.getElementById('gen-status-text');
           const modelEl = document.getElementById('gen-model-tag');
           const timeEl = document.getElementById('gen-updated-time');
           const dotEl = document.getElementById('gen-status-dot');
           const uploadStatusEl = document.getElementById('upload-status');
           if (!statusEl || !modelEl || !timeEl || !dotEl) return;

           statusEl.textContent = `Generation: ${GENERATION_UI_STATE.message}`;
           modelEl.textContent = `Model: ${GENERATION_UI_STATE.modelTag}`;
           timeEl.textContent = `Updated: ${formatShortTime(GENERATION_UI_STATE.updatedAtUtc)}`;

           dotEl.classList.remove('idle', 'running', 'ready', 'error');
           dotEl.classList.add(GENERATION_UI_STATE.status || 'idle');

           if (uploadStatusEl) {
               uploadStatusEl.classList.toggle('running', GENERATION_UI_STATE.status === 'running');
           }
       }

       function inferUploaderFromImageUrl(imageUrl) {
           if (!imageUrl || !CURRENT_USER_ID) return null;
           const urlText = String(imageUrl);
           const pathNeedle = `/${CURRENT_USER_ID}/`;
           if (!urlText.includes(pathNeedle)) return null;
           return {
               uploaderName: CURRENT_UPLOADER_NAME || deriveUploaderNameFromEmail(CURRENT_USER_EMAIL),
               uploaderEmail: CURRENT_USER_EMAIL || ''
           };
       }

       function parseUploaderUserIdFromImageUrl(imageUrl) {
           if (!imageUrl) return '';
           try {
               const urlObj = new URL(String(imageUrl));
               const parts = urlObj.pathname.split('/').filter(Boolean);
               return parts[0] || '';
           } catch (_err) {
               const match = String(imageUrl).match(/almostcrackd\.ai\/([^/]+)\//i);
               return match ? match[1] : '';
           }
       }

       function extractUploaderIdentity(item) {
           const row = item || {};
           const uploaderEmail = String(
               row.uploader_email
               || row.uploaderEmail
               || row.uploaded_by_email
               || row.created_by_email
               || row.user_email
               || ''
           ).trim();
           const uploaderName = String(
               row.uploader_name
               || row.uploaderName
               || row.uploaded_by_name
               || row.created_by_name
               || ''
           ).trim();
           const uploaderUserId = String(
               row.uploader_user_id
               || row.uploaderUserId
               || row.uploaded_by_user_id
               || row.created_by_user_id
               || row.profile_id
               || row.user_id
               || ''
           ).trim();
           return { uploaderEmail, uploaderName, uploaderUserId };
       }
      
       function logMsg(msg, color = "#fff") {
           const box = document.getElementById('click-logger');
           const content = document.getElementById('log-content');
           if (color === "red") box.style.display = 'block';
           const line = document.createElement('div');
           line.style.color = color;
           line.innerText = `> ${msg}`;
           content.prepend(line);
       }

       function detectPhoneClient() {
           const ua = String(navigator.userAgent || '').toLowerCase();
           const hasMobileUA = /iphone|ipod|android|mobile|ipad/.test(ua);
           const narrow = window.matchMedia && window.matchMedia(PHONE_MEDIA_QUERY).matches;
           return Boolean(hasMobileUA || narrow);
       }

       function applyClientMode() {
           IS_PHONE_CLIENT = detectPhoneClient();
           document.body.classList.toggle('iphone-mode', IS_PHONE_CLIENT);
       }

       function updateSideTabs() {
           const gridBtn = document.getElementById('tab-grid');
           const swipeBtn = document.getElementById('tab-swipe');
           const uploadBtn = document.getElementById('tab-upload');
           const accountBtn = document.getElementById('tab-account');
           const discoverBtn = document.getElementById('tab-discover');
           const communitiesBtn = document.getElementById('tab-communities');
           if (!gridBtn || !swipeBtn || !uploadBtn || !accountBtn || !discoverBtn || !communitiesBtn) return;
           gridBtn.classList.toggle('active', currentView === 'grid');
           swipeBtn.classList.toggle('active', currentView === 'swipe');
           uploadBtn.classList.toggle('active', currentView === 'upload');
           accountBtn.classList.toggle('active', currentView === 'account');
           discoverBtn.classList.toggle('active', currentView === 'discover');
           communitiesBtn.classList.toggle('active', currentView === 'communities');
       }

       function updateTopControls() {
           const searchBar = document.querySelector('.search-wrapper');
           if (!searchBar) return;
           searchBar.style.display = (currentView === 'upload' || currentView === 'account' || currentView === 'discover' || currentView === 'communities') ? 'none' : 'block';
       }

       function getFilteredMemes() {
           if (!currentSearchTerm) return allMemes;
           return allMemes.filter(m => m.content && m.content.toLowerCase().includes(currentSearchTerm));
       }

       function switchView(view) {
           currentView = view;
           updateSideTabs();
           updateTopControls();
           renderCurrentView();
       }

       function draw() {
           renderCurrentView();
       }

       async function withTimeout(promise, ms, label) {
           let timer = null;
           const timeoutPromise = new Promise((_, reject) => {
               timer = setTimeout(() => reject(new Error(`${label} timed out after ${ms}ms`)), ms);
           });
           return Promise.race([promise, timeoutPromise]).finally(() => {
               if (timer) clearTimeout(timer);
           });
       }

       async function fetchWithTimeout(url, options, ms, label) {
           const controller = new AbortController();
           const timer = setTimeout(() => controller.abort(), ms);
           try {
               const res = await fetch(url, { ...options, signal: controller.signal });
               return res;
           } catch (err) {
               if (err && err.name === 'AbortError') {
                   throw new Error(`${label} timed out after ${ms}ms`);
               }
               throw err;
           } finally {
               clearTimeout(timer);
           }
       }

       function chunkArray(items, size) {
           const out = [];
           for (let i = 0; i < items.length; i += size) {
               out.push(items.slice(i, i + size));
           }
           return out;
       }

       async function fetchRecentCaptions(client, pageSize = 1000, maxPages = 8) {
           const all = [];
           for (let page = 0; page < maxPages; page += 1) {
               const from = page * pageSize;
               const to = from + pageSize - 1;
               const { data, error } = await client
                   .from('captions')
                   .select('*')
                   .order('created_datetime_utc', { ascending: false })
                   .range(from, to);
               if (error) throw error;
               if (!data || !data.length) break;
               all.push(...data);
               if (data.length < pageSize) break;
           }
           return all;
       }

       async function fetchImagesByIds(client, ids) {
           const imageMap = {};
           const uniqueIds = Array.from(new Set((ids || []).filter(Boolean)));
           const chunks = chunkArray(uniqueIds, 150);
           for (const batch of chunks) {
               if (!batch.length) continue;
               const { data, error } = await client.from('images').select('id, url').in('id', batch);
               if (error) throw error;
               (data || []).forEach(img => {
                   imageMap[img.id] = img.url;
               });
           }
           return imageMap;
       }

       function getSwipeProgressKey() {
           return CURRENT_USER_ID ? `${SWIPE_PROGRESS_KEY_PREFIX}${CURRENT_USER_ID}` : null;
       }

       function getGeneratedMemesKey() {
           return CURRENT_USER_ID ? `${GENERATED_MEMES_KEY_PREFIX}${CURRENT_USER_ID}` : null;
       }

       function getDisplayNameKey() {
           return CURRENT_USER_ID ? `display_name_v1_${CURRENT_USER_ID}` : null;
       }

       function getCurrentDisplayName() {
           const key = getDisplayNameKey();
           if (!key) return CURRENT_UPLOADER_NAME;
           try {
               const saved = localStorage.getItem(key);
               if (saved && saved.trim()) return saved.trim();
           } catch (_err) {}
           return CURRENT_UPLOADER_NAME;
       }

       function saveDisplayName(name) {
           const clean = String(name || '').trim();
           if (!CURRENT_USER_ID || !clean) return;
           const key = getDisplayNameKey();
           if (!key) return;
           localStorage.setItem(key, clean);
           CURRENT_UPLOADER_NAME = clean;
       }

       function isOwnedByCurrentUser(item) {
           if (!item) return false;
           if (item.uploaderEmail && CURRENT_USER_EMAIL && item.uploaderEmail === CURRENT_USER_EMAIL) return true;
           if (item.imageUrl && CURRENT_USER_ID) return String(item.imageUrl).includes(`/${CURRENT_USER_ID}/`);
           return false;
       }

       function getOwnedUploads() {
           const groups = new Map();
           allMemes.forEach(item => {
               if (!isOwnedByCurrentUser(item)) return;
               const imageId = item.image_id || `local-${item.id}`;
               const existing = groups.get(imageId) || {
                   imageId,
                   imageUrl: item.imageUrl || null,
                   captions: []
               };
               if (!existing.imageUrl && item.imageUrl) existing.imageUrl = item.imageUrl;
               existing.captions.push(item);
               groups.set(imageId, existing);
           });
           return Array.from(groups.values()).sort((a, b) => (b.captions.length - a.captions.length));
       }

       function getUploaderKey(item) {
           if (!item) return '';
           return item.uploaderEmail || item.uploaderUserId || `unknown-${item.id}`;
       }

       function getUploaderLabel(item) {
           if (item.uploaderEmail) return item.uploaderEmail;
           return 'Email unavailable';
       }

       function getUploadsByUploader(searchTerm = '') {
           const term = String(searchTerm || '').toLowerCase().trim();
           const groups = new Map();

           allMemes.forEach(item => {
               const key = getUploaderKey(item);
               if (!key) return;
               const existing = groups.get(key) || {
                   key,
                   label: getUploaderLabel(item),
                   uploaderName: item.uploaderName || '',
                   uploaderEmail: item.uploaderEmail || '',
                   uploaderUserId: item.uploaderUserId || '',
                   items: [],
                   imageIds: new Set()
               };
               existing.items.push(item);
               if (item.image_id) existing.imageIds.add(item.image_id);
               groups.set(key, existing);
           });

           return Array.from(groups.values())
               .map(group => ({
                   ...group,
                   totalCaptions: group.items.length,
                   totalImages: group.imageIds.size,
                   searchValue: `${group.label} ${group.uploaderName} ${group.uploaderEmail} ${group.uploaderUserId}`.toLowerCase()
               }))
               .filter(group => !term || group.searchValue.includes(term))
               .sort((a, b) => b.totalCaptions - a.totalCaptions);
       }

       function dedupeMemes(memes) {
           const byId = new Map();
           const out = [];
           (Array.isArray(memes) ? memes : []).forEach((item, index) => {
               if (!item || typeof item !== 'object') return;
               const id = item.id || item.caption_id || `generated-fallback-${index}`;
               if (byId.has(id)) return;
               const normalized = {
                   ...item,
                   id,
                   content: item.content || item.caption_text || '',
                   imageUrl: item.imageUrl || item.url || null
               };
               const extractedIdentity = extractUploaderIdentity(normalized);
               if (extractedIdentity.uploaderEmail && !normalized.uploaderEmail) normalized.uploaderEmail = extractedIdentity.uploaderEmail;
               if (extractedIdentity.uploaderName && !normalized.uploaderName) normalized.uploaderName = extractedIdentity.uploaderName;
               if (extractedIdentity.uploaderUserId && !normalized.uploaderUserId) normalized.uploaderUserId = extractedIdentity.uploaderUserId;
               if (!normalized.uploaderUserId) {
                   normalized.uploaderUserId = parseUploaderUserIdFromImageUrl(normalized.imageUrl);
               }
               const inferredUploader = inferUploaderFromImageUrl(normalized.imageUrl);
               if (!normalized.uploaderName && inferredUploader) {
                   normalized.uploaderName = inferredUploader.uploaderName;
               }
               if (!normalized.uploaderEmail && inferredUploader) {
                   normalized.uploaderEmail = inferredUploader.uploaderEmail;
               }
               if (typeof normalized.aiGenerated === 'undefined') {
                   const looksLikeGenerated = String(normalized.id).startsWith('generated-') ||
                       (normalized.imageUrl || '').includes('presigned-url-uploads.almostcrackd.ai');
                   normalized.aiGenerated = looksLikeGenerated;
               }
               if (normalized.aiGenerated && !normalized.aiModelTag) {
                   normalized.aiModelTag = 'caption-pipeline-v1';
               }
               if (normalized.aiGenerated && !normalized.generatedAtUtc) {
                   normalized.generatedAtUtc = normalized.created_datetime_utc || new Date().toISOString();
               }
               if (normalized.aiGenerated && !normalized.generationStatus) {
                   normalized.generationStatus = 'ready';
               }
               normalized.communityName = getMemeCommunity(normalized);
               byId.set(id, true);
               out.push(normalized);
           });
           return out;
       }

       function saveGeneratedMemes() {
           const key = getGeneratedMemesKey();
           if (!key) return;
           try {
               localStorage.setItem(key, JSON.stringify(dedupeMemes(generatedMemes)));
           } catch (_err) {}
       }

       function restoreGeneratedMemes() {
           const key = getGeneratedMemesKey();
           if (!key) {
               generatedMemes = [];
               return;
           }
           try {
               const raw = localStorage.getItem(key);
               if (!raw) {
                   generatedMemes = [];
                   return;
               }
               generatedMemes = dedupeMemes(JSON.parse(raw));
           } catch (_err) {
               generatedMemes = [];
           }
       }

       function saveSwipeProgress() {
           if (!CURRENT_USER_ID || currentSearchTerm) return;
           const key = getSwipeProgressKey();
           if (!key) return;
           localStorage.setItem(key, JSON.stringify({
               swipeIndex,
               swipeHistory
           }));
       }

       function restoreSwipeProgress() {
           if (!CURRENT_USER_ID) return;
           const key = getSwipeProgressKey();
           if (!key) return;
           const raw = localStorage.getItem(key);
           if (!raw) {
               swipeIndex = 0;
               swipeHistory = [];
               return;
           }
           try {
               const parsed = JSON.parse(raw);
               swipeIndex = Number(parsed.swipeIndex);
               if (!Number.isFinite(swipeIndex) || swipeIndex < 0) swipeIndex = 0;
               swipeHistory = Array.isArray(parsed.swipeHistory)
                   ? parsed.swipeHistory.filter(n => Number.isInteger(n) && n >= 0)
                   : [];
           } catch (_err) {
               swipeIndex = 0;
               swipeHistory = [];
           }
       }

       async function signIn() {
           const client = getClient();
           await client.auth.signInWithOAuth({
               provider: 'google',
               options: { redirectTo: window.location.origin + '/auth/callback' }
           })
       }

       async function getAccessToken() {
           if (CURRENT_ACCESS_TOKEN) return CURRENT_ACCESS_TOKEN;
           const client = getClient();
           console.log('[Auth] Getting session token...');
           const { data: { session }, error } = await withTimeout(
               client.auth.getSession(),
               7000,
               'getSession'
           );
           if (error || !session?.access_token) {
               throw new Error('No access token available. Please sign in again.');
           }
           CURRENT_ACCESS_TOKEN = session.access_token;
           return session.access_token;
       }

       function setUploadStatus(message, isError = false) {
           const messageText = message || '';
           const statusNodes = [
               document.getElementById('upload-status'),
               document.getElementById('community-upload-status')
           ].filter(Boolean);
           if (!statusNodes.length) return;
           statusNodes.forEach(status => {
               status.textContent = messageText;
               status.classList.toggle('error', Boolean(isError));
               status.classList.toggle('running', !isError && !!messageText);
           });
           communityUploadStatus = messageText;
       }

       function normalizeGeneratedCaptions(captions, cdnUrl, imageId = null) {
           const list = Array.isArray(captions) ? captions : [];
           const generatedAtUtc = new Date().toISOString();
           return list.map((item, index) => ({
               ...item,
               id: item.id || item.caption_id || `generated-${Date.now()}-${index}`,
               content: item.content || item.caption_text || '',
               imageUrl: cdnUrl,
               image_id: item.image_id || imageId || null,
               uploaderName: item.uploaderName || CURRENT_UPLOADER_NAME || deriveUploaderNameFromEmail(CURRENT_USER_EMAIL),
               uploaderEmail: item.uploaderEmail || CURRENT_USER_EMAIL || '',
               uploaderUserId: item.uploaderUserId || CURRENT_USER_ID || '',
               aiGenerated: true,
               aiModelTag: item.model || item.modelTag || 'caption-pipeline-v1',
               generatedAtUtc: item.generatedAtUtc || item.created_datetime_utc || generatedAtUtc,
               generationStatus: 'ready'
            }));
        }

       async function persistUploaderIdentityForImage(client, imageId) {
           if (!client || !imageId || !CURRENT_USER_EMAIL) return;
           const displayName = getCurrentDisplayName() || deriveUploaderNameFromEmail(CURRENT_USER_EMAIL);
           const payloads = [
               { uploader_email: CURRENT_USER_EMAIL, uploader_name: displayName, uploader_user_id: CURRENT_USER_ID },
               { uploaded_by_email: CURRENT_USER_EMAIL, uploaded_by_name: displayName, uploaded_by_user_id: CURRENT_USER_ID },
               { created_by_email: CURRENT_USER_EMAIL, created_by_name: displayName, created_by_user_id: CURRENT_USER_ID }
           ];
           for (const payload of payloads) {
               const { error } = await client.from('captions').update(payload).eq('image_id', imageId);
               if (!error) {
                   console.log('[UploaderIdentity] Stored uploader identity for image', imageId);
                   return;
               }
               const msg = String(error.message || '').toLowerCase();
               const isMissingColumn = msg.includes('column') && msg.includes('does not exist');
               if (!isMissingColumn) {
                   console.warn('[UploaderIdentity] Could not persist identity', error.message);
                   return;
               }
           }
           console.warn('[UploaderIdentity] No compatible uploader identity columns found on captions table');
       }

       function renderUploaderMeta(item) {
           if (!item) return '';
           const email = String(item.uploaderEmail || '').trim();
           if (email) return `<div class="uploader-meta">Uploaded by ${escapeHtml(email)}</div>`;
           const name = String(item.uploaderName || '').trim();
           if (name) return `<div class="uploader-meta">Uploaded by ${escapeHtml(name)}</div>`;
           return '';
       }

       function renderCommunityMeta(item) {
           const community = escapeHtml(getMemeCommunity(item));
           return `<div class="community-meta"><span class="community-pill">${community}</span></div>`;
       }

       function renderHeaderActions(showRefresh = true) {
           return `
               <div class="top-actions">
                   ${showRefresh ? `
                   <button class="logout-btn" onclick="refreshFeed(true)">
                       <i class="fa-solid fa-rotate"></i> Refresh feed
                   </button>` : ''}
                   <button class="logout-btn" onclick="getClient().auth.signOut().then(() => location.reload())">
                       <i class="fa-solid fa-arrow-right-from-bracket"></i> Log out
                   </button>
               </div>`;
       }

       function renderAIMeta(item) {
           if (!item || !item.aiGenerated) return '';
           const model = escapeHtml(item.aiModelTag || 'caption-pipeline-v1');
           const generatedAt = formatShortTime(item.generatedAtUtc);
           const status = escapeHtml(item.generationStatus || 'ready');
           return `<div class="ai-meta"><span class="ai-pill">AI</span><span class="ai-meta-text">${model}</span><span class="ai-meta-text">${generatedAt}</span><span class="ai-meta-text">${status}</span></div>`;
       }

       function scheduleRealtimeRefresh() {
           if (REALTIME_REFRESH_TIMER) return;
           REALTIME_REFRESH_TIMER = setTimeout(() => {
               REALTIME_REFRESH_TIMER = null;
               refreshFeed(false).catch(err => console.error('[RealtimeRefresh]', err));
           }, 1200);
       }

       function startRealtimeSync() {
           const client = getClient();
           stopRealtimeSync();
           REALTIME_CHANNEL = client
               .channel('app-live-updates')
               .on('postgres_changes', { event: '*', schema: 'public', table: 'captions' }, scheduleRealtimeRefresh)
               .on('postgres_changes', { event: '*', schema: 'public', table: 'caption_votes' }, scheduleRealtimeRefresh)
               .subscribe();
       }

       function stopRealtimeSync() {
           const client = getClient();
           if (REALTIME_CHANNEL) {
               client.removeChannel(REALTIME_CHANNEL);
               REALTIME_CHANNEL = null;
           }
           if (REALTIME_REFRESH_TIMER) {
               clearTimeout(REALTIME_REFRESH_TIMER);
               REALTIME_REFRESH_TIMER = null;
           }
       }

       function extractGeneratedCaptions(step4Data) {
           if (Array.isArray(step4Data)) return step4Data;
           if (!step4Data || typeof step4Data !== 'object') return [];
           if (Array.isArray(step4Data.captions)) return step4Data.captions;
           if (Array.isArray(step4Data.records)) return step4Data.records;
           if (Array.isArray(step4Data.data)) return step4Data.data;
           if (step4Data.data && Array.isArray(step4Data.data.captions)) return step4Data.data.captions;
           if (step4Data.caption && typeof step4Data.caption === 'object') return [step4Data.caption];
           if (step4Data.data && step4Data.data.caption && typeof step4Data.data.caption === 'object') return [step4Data.data.caption];
           if (step4Data.content || step4Data.caption_text) return [step4Data];
           return [];
       }

       async function handleImageUpload(file, targetCommunity = null) {
           if (!file) return;
           const communityName = ensureCommunityExists(targetCommunity || selectedCommunityName || 'General');
           const nowMs = Date.now();
           if (UPLOAD_IN_FLIGHT) {
               setUploadStatus('Upload already in progress. Please wait.', true);
               return;
           }
           if (nowMs - LAST_UPLOAD_AT < UPLOAD_COOLDOWN_MS) {
               setUploadStatus('Please wait a moment before uploading again.', true);
               return;
           }
           if (!SUPPORTED_IMAGE_TYPES.has(file.type)) {
               setUploadStatus(`That file type is not supported: ${file.type || 'unknown'}`, true);
               return;
           }
           if (file.size > MAX_UPLOAD_BYTES) {
               setUploadStatus(`File too large. Max size is ${Math.round(MAX_UPLOAD_BYTES / (1024 * 1024))}MB.`, true);
               return;
           }

           try {
               UPLOAD_IN_FLIGHT = true;
               LAST_UPLOAD_AT = nowMs;
               const client = getClient();
               setGenerationUIState({
                   status: 'running',
                   message: 'Preparing upload',
                   modelTag: GENERATION_UI_STATE.modelTag || 'caption-pipeline-v1'
               });
               setUploadStatus('Packing your image...');
               console.log('[Pipeline] Starting upload', { name: file.name, type: file.type, size: file.size });
               const token = await getAccessToken();
               setUploadStatus('Requesting an upload lane...');

               console.log('[Pipeline Step 1] Generate presigned URL', { contentType: file.type });
               const step1Res = await fetchWithTimeout(`${PIPELINE_BASE_URL}/pipeline/generate-presigned-url`, {
                   method: 'POST',
                   headers: {
                       Authorization: `Bearer ${token}`,
                       'Content-Type': 'application/json'
                   },
                   body: JSON.stringify({ contentType: file.type })
               }, 20000, 'Step 1');
               if (!step1Res.ok) throw new Error(`Step 1 failed: ${step1Res.status}`);
               const step1Data = await step1Res.json();
               const presignedUrl = step1Data.presignedUrl;
               const cdnUrl = step1Data.cdnUrl;
               setGenerationUIState({ status: 'running', message: 'Uploading bytes' });
               console.log('[Pipeline Step 1] Success', { presignedUrl, cdnUrl });

               setUploadStatus('Uploading pixels...');
               console.log('[Pipeline Step 2] Upload bytes to presigned URL');
               const step2Res = await fetchWithTimeout(presignedUrl, {
                   method: 'PUT',
                   headers: {
                       'Content-Type': file.type
                   },
                   body: file
               }, 40000, 'Step 2');
               if (!step2Res.ok) throw new Error(`Step 2 failed: ${step2Res.status}`);
               setGenerationUIState({ status: 'running', message: 'Registering image' });
               console.log('[Pipeline Step 2] Success');

               setUploadStatus('Registering your upload...');
               console.log('[Pipeline Step 3] Register image URL', { imageUrl: cdnUrl });
               const step3Res = await fetchWithTimeout(`${PIPELINE_BASE_URL}/pipeline/upload-image-from-url`, {
                   method: 'POST',
                   headers: {
                       Authorization: `Bearer ${token}`,
                       'Content-Type': 'application/json'
                   },
                   body: JSON.stringify({
                       imageUrl: cdnUrl,
                       isCommonUse: false
                   })
               }, 20000, 'Step 3');
               if (!step3Res.ok) throw new Error(`Step 3 failed: ${step3Res.status}`);
               const step3Data = await step3Res.json();
               const imageId = step3Data.imageId;
               setGenerationUIState({ status: 'running', message: 'Generating captions' });
               console.log('[Pipeline Step 3] Success', { imageId });

               setUploadStatus('Generating caption options...');
               console.log('[Pipeline Step 4] Generate captions', { imageId });
               const step4Res = await fetchWithTimeout(`${PIPELINE_BASE_URL}/pipeline/generate-captions`, {
                   method: 'POST',
                   headers: {
                       Authorization: `Bearer ${token}`,
                       'Content-Type': 'application/json'
                   },
                   body: JSON.stringify({ imageId })
               }, 45000, 'Step 4');
               if (!step4Res.ok) throw new Error(`Step 4 failed: ${step4Res.status}`);
               const step4Data = await step4Res.json();
               const modelTag = extractModelTag(step4Data);
               setGenerationUIState({ status: 'ready', message: 'Captions ready', modelTag });
               console.log('[Pipeline Step 4] Success', step4Data);

               const generated = extractGeneratedCaptions(step4Data);
               console.log('[Pipeline Step 4] Captions extracted', { count: generated.length });
               const newCaptions = normalizeGeneratedCaptions(generated, cdnUrl, imageId);
               newCaptions.forEach(item => {
                   item.aiModelTag = modelTag;
                   item.communityName = communityName;
                   if (item.id) communityByCaptionId[item.id] = communityName;
               });
               if (imageId) communityByImageId[imageId] = communityName;
               saveCommunityState();
               if (newCaptions.length) {
                   generatedMemes = dedupeMemes([...newCaptions, ...generatedMemes]);
                   saveGeneratedMemes();
                   allMemes = applyCommunityMetadata(dedupeMemes([...generatedMemes, ...allMemes]));
                   setUploadStatus(`New batch ready: ${newCaptions.length} caption(s).`);
                   communityUploadStatus = `Uploaded to ${communityName}. ${newCaptions.length} caption(s) generated.`;
               } else {
                   setUploadStatus('Upload succeeded, but no captions were returned.');
                   communityUploadStatus = `Upload reached ${communityName}, but no captions were returned.`;
               }

               // Verify DB persistence and refresh from DB so all users can see the same feed.
               await persistUploaderIdentityForImage(client, imageId);
               const { data: persistedRows, error: persistedError } = await client
                   .from('captions')
                   .select('id')
                   .eq('image_id', imageId)
                   .limit(1);
               if (!persistedError && persistedRows && persistedRows.length) {
                   setUploadStatus('Saved to shared feed.');
                   await refreshFeed(false);
               } else if (persistedError) {
                   console.warn('[Pipeline] Persist check failed', persistedError);
               }

               swipeIndex = 0;
               swipeHistory = [];
               saveSwipeProgress();
               switchView(targetCommunity ? 'communities' : 'upload');
           } catch (err) {
               console.error('[Pipeline] Upload flow failed', err);
               setGenerationUIState({ status: 'error', message: 'Generation failed' });
               setUploadStatus(err.message || 'Upload failed.', true);
               if (targetCommunity) communityUploadStatus = err.message || 'Upload failed.';
           } finally {
               UPLOAD_IN_FLIGHT = false;
           }
       }

       function setupUpload() {
           const oldInput = document.getElementById('image-upload');
           if (!oldInput) return;
           const newInput = oldInput.cloneNode(true);
           oldInput.parentNode.replaceChild(newInput, oldInput);
           newInput.addEventListener('change', async (e) => {
               const file = e.target.files && e.target.files[0];
               await handleImageUpload(file);
               newInput.value = '';
           });
       }

       function setupCommunityUploadInput() {
           const oldInput = document.getElementById('community-image-upload');
           if (!oldInput) return;
           const newInput = oldInput.cloneNode(true);
           oldInput.parentNode.replaceChild(newInput, oldInput);
           newInput.addEventListener('change', (e) => {
               const file = e.target.files && e.target.files[0];
               if (!file) return;
               setUploadStatus(`Ready to upload: ${file.name}`);
           });
       }

       async function handleCommunityUploadClick() {
           const input = document.getElementById('community-image-upload');
           if (!input) return;
           const file = input.files && input.files[0];
           if (!file) {
               setUploadStatus('Select an image first.', true);
               return;
           }
           await handleImageUpload(file, selectedCommunityName);
           input.value = '';
       }

       function handleCreateCommunity() {
           const input = document.getElementById('community-title-input');
           if (!input) return;
           const name = normalizeCommunityName(input.value);
           if (!name) {
               communityCreateMessage = 'Community title is required.';
               renderCurrentView();
               return;
           }
           ensureCommunityExists(name);
           selectedCommunityName = name;
           communityCreateMessage = `Community "${name}" is ready.`;
           input.value = '';
           saveCommunityState();
           syncCommunitiesToProfile().catch(err => console.warn('[Communities] sync error', err));
           renderCurrentView();
       }

       function handleCommunitySelection(value) {
           selectedCommunityName = ensureCommunityExists(value || 'General');
           saveCommunityState();
           renderCurrentView();
       }

       async function refreshFeed(showNotice = false) {
           if (!CURRENT_USER_ID) return;
           if (FEED_FETCH_IN_FLIGHT) {
               FEED_FETCH_QUEUED = true;
               return;
           }
           const container = document.getElementById('content-view');
           const client = getClient();
           await fetchAndShowMemes(client, container);
           if (showNotice) setUploadStatus('Feed refreshed.');
       }

       function startAutoRefresh() {
           if (AUTO_REFRESH_TIMER) clearInterval(AUTO_REFRESH_TIMER);
           if (!VISIBILITY_HOOK_SET) {
               document.addEventListener('visibilitychange', () => {
                   if (!document.hidden) {
                       refreshFeed(false).catch(err => console.error('[AutoRefresh]', err));
                   }
               });
               VISIBILITY_HOOK_SET = true;
           }
           AUTO_REFRESH_TIMER = setInterval(() => {
               if (document.hidden) return;
               refreshFeed(false).catch(err => console.error('[AutoRefresh]', err));
           }, FEED_REFRESH_MS);
       }

       function stopAutoRefresh() {
           if (!AUTO_REFRESH_TIMER) return;
           clearInterval(AUTO_REFRESH_TIMER);
           AUTO_REFRESH_TIMER = null;
       }

       async function deleteUploadByImageId(imageId) {
           if (!CURRENT_USER_ID) return;
           if (!imageId) {
               ACCOUNT_ACTION_MESSAGE = 'Cannot delete this upload because the image id is missing.';
               renderCurrentView();
               return;
           }
           const confirmDelete = window.confirm('Delete this upload and all captions from it?');
           if (!confirmDelete) return;

           ACCOUNT_ACTION_MESSAGE = 'Deleting upload...';
           renderCurrentView();

           if (String(imageId).startsWith('local-')) {
               const localCaptionId = String(imageId).replace('local-', '');
               allMemes = allMemes.filter(item => item.id !== localCaptionId);
               generatedMemes = generatedMemes.filter(item => item.id !== localCaptionId);
               saveGeneratedMemes();
               ACCOUNT_ACTION_MESSAGE = 'Deleted local upload.';
               renderCurrentView();
               return;
           }

           const ownedCandidate = allMemes.find(item => item.image_id === imageId && isOwnedByCurrentUser(item));
           if (!ownedCandidate) {
               ACCOUNT_ACTION_MESSAGE = 'Delete blocked: you can only delete your own uploads.';
               renderCurrentView();
               return;
           }

           const client = getClient();
           const captionIds = allMemes
               .filter(item => item.image_id === imageId)
               .map(item => item.id);
           captionIds.forEach(captionId => {
               delete communityByCaptionId[captionId];
           });
           delete communityByImageId[imageId];
           saveCommunityState();
           if (captionIds.length) {
               await client.from('caption_votes').delete().in('caption_id', captionIds);
           }

           const { error: captionDeleteError } = await client.from('captions').delete().eq('image_id', imageId);
           if (captionDeleteError) {
               ACCOUNT_ACTION_MESSAGE = `Delete failed: ${captionDeleteError.message}`;
               renderCurrentView();
               return;
           }
           const { error: imageDeleteError } = await client.from('images').delete().eq('id', imageId);
           if (imageDeleteError) {
               ACCOUNT_ACTION_MESSAGE = `Captions deleted, but image record could not be removed: ${imageDeleteError.message}`;
               renderCurrentView();
               return;
           }

           allMemes = allMemes.filter(item => item.image_id !== imageId);
           generatedMemes = generatedMemes.filter(item => item.image_id !== imageId);
           saveGeneratedMemes();
           ACCOUNT_ACTION_MESSAGE = 'Upload deleted.';
           renderCurrentView();
       }

       function handleSaveDisplayName() {
           const input = document.getElementById('display-name-input');
           if (!input) return;
           const value = input.value.trim();
           if (!value) {
               alert('Display name cannot be empty.');
               return;
           }
           saveDisplayName(value);
           allMemes = allMemes.map(item => isOwnedByCurrentUser(item)
               ? { ...item, uploaderName: value, uploaderEmail: CURRENT_USER_EMAIL || item.uploaderEmail }
               : item
           );
           generatedMemes = generatedMemes.map(item => isOwnedByCurrentUser(item)
               ? { ...item, uploaderName: value, uploaderEmail: CURRENT_USER_EMAIL || item.uploaderEmail }
               : item
           );
           saveGeneratedMemes();
           ACCOUNT_ACTION_MESSAGE = 'Display name updated across your uploads.';
           renderCurrentView();
       }

       function clearUploaderSearch() {
           uploaderSearchTerm = '';
           const input = document.getElementById('uploader-search-input');
           if (input) input.value = '';
           renderUploaderDirectorySection();
       }

       function setupUploaderSearch() {
           const oldInput = document.getElementById('uploader-search-input');
           if (!oldInput) return;
           const newInput = oldInput.cloneNode(true);
           oldInput.parentNode.replaceChild(newInput, oldInput);
           newInput.addEventListener('input', (e) => {
               uploaderSearchTerm = e.target.value.toLowerCase();
               renderUploaderDirectorySection();
           });
       }

       function renderUploaderDirectorySection() {
           const uploaderGroups = getUploadsByUploader(uploaderSearchTerm);
           const totalUploaderGroups = getUploadsByUploader('').length;
           const countEl = document.getElementById('uploader-count-label');
           const listEl = document.getElementById('uploader-directory-container');
           if (!countEl || !listEl) return;

           countEl.textContent = `Showing ${uploaderGroups.length} of ${totalUploaderGroups} uploaders`;
           if (!uploaderGroups.length) {
               listEl.innerHTML = `<p class="upload-empty">No users match that search.</p>`;
               return;
           }

           let html = `<div class="uploader-directory">`;
           uploaderGroups.forEach(group => {
               const previews = group.items.slice(0, 4);
               const safeLabel = escapeHtml(group.label);
               html += `
                   <article class="uploader-card">
                       <div class="uploader-card-head">
                           <div class="uploader-card-title">${safeLabel}</div>
                           <div class="uploader-card-meta">${group.totalCaptions} captions  ${group.totalImages} images</div>
                       </div>
                       <div class="uploader-preview-grid">`;
               previews.forEach(item => {
                   const fallbackGif = "https://media.giphy.com/media/v1.Y2lkPTc5MGI3NjExM3R6eW55b3R6eW55b3R6eW55/26hkhKd9CQeRv7lqM/giphy.gif";
                   const displayUrl = safeUrl(item.imageUrl, fallbackGif);
                   html += `
                           <div class="uploader-preview-item">
                               <img src="${displayUrl}" class="uploader-preview-image" alt="Uploader meme preview">
                               <div class="uploader-preview-caption">${safePreviewText(item.content || '')}</div>
                           </div>`;
               });
               html += `
                       </div>
                   </article>`;
           });
           html += `</div>`;
           listEl.innerHTML = html;
       }
      
       async function renderApp() {
           applyClientMode();
           const container = document.getElementById('content-view');
           const searchBar = document.querySelector('.search-wrapper');
           const sidebar = document.getElementById('sidebar');
           const client = getClient();
          
           const { data: { session } } = await client.auth.getSession();
          
           if (session) {
               CURRENT_USER_ID = session.user.id;
               CURRENT_ACCESS_TOKEN = session.access_token || null;
               setCurrentUserIdentity(session.user);
               CURRENT_UPLOADER_NAME = getCurrentDisplayName();
               loadCommunityState();
               await hydrateCommunitiesFromProfile(session.user);
               sidebar.style.display = 'flex';
               document.body.classList.add('has-sidebar');
               startAutoRefresh();
               startRealtimeSync();
               await fetchAndShowMemes(client, container);
           } else {
               CURRENT_ACCESS_TOKEN = null;
               CURRENT_USER_EMAIL = '';
               CURRENT_UPLOADER_NAME = '';
               stopAutoRefresh();
               stopRealtimeSync();
               searchBar.style.display = 'none';
               sidebar.style.display = 'none';
               document.body.classList.remove('has-sidebar');
               container.innerHTML = `
                   <div class="auth-box">
                       <div class="auth-kicker">SIGN IN</div>
                       <h2>Brain Rot Central</h2>
                       <p class="auth-subtext">Sign in with Google to vote, swipe, and generate new captions.</p>
                       <button class="login-btn" onclick="signIn()">
                           <i class="fa-brands fa-google"></i> Sign in with Google
                       </button>
                       <div class="auth-meta">Callback route: /auth/callback</div>
                   </div>`;
           }

           client.auth.onAuthStateChange(async (_event, currentSession) => {
               if (currentSession) {
                   CURRENT_USER_ID = currentSession.user.id;
                   CURRENT_ACCESS_TOKEN = currentSession.access_token || null;
                   setCurrentUserIdentity(currentSession.user);
                   CURRENT_UPLOADER_NAME = getCurrentDisplayName();
                   loadCommunityState();
                   await hydrateCommunitiesFromProfile(currentSession.user);
                   sidebar.style.display = 'flex';
                   document.body.classList.add('has-sidebar');
                   startAutoRefresh();
                   startRealtimeSync();
                   await fetchAndShowMemes(client, container);
               } else {
                   CURRENT_ACCESS_TOKEN = null;
                   CURRENT_USER_EMAIL = '';
                   CURRENT_UPLOADER_NAME = '';
                   stopAutoRefresh();
                   stopRealtimeSync();
               }
           });
       }

       async function fetchAndShowMemes(client, container) {
           if (FEED_FETCH_IN_FLIGHT) {
               FEED_FETCH_QUEUED = true;
               return;
           }
           FEED_FETCH_IN_FLIGHT = true;
           try {
               let captions = [];
               try {
                   captions = await fetchRecentCaptions(client, 1000, 8);
               } catch (error) {
                   const msg = String(error && error.message ? error.message : error);
                   if (msg.includes('Navigator LockManager') || msg.includes('timed out waiting')) {
                       await new Promise(resolve => setTimeout(resolve, 700));
                       captions = await fetchRecentCaptions(client, 1000, 8);
                   } else {
                       throw error;
                   }
               }

               try {
                   imageUrlById = await fetchImagesByIds(client, captions.map(c => c.image_id));
               } catch (error) {
                   logMsg("Error images: " + error.message, "red");
                   imageUrlById = {};
               }

               const localVotes = JSON.parse(localStorage.getItem('my_votes_v1') || '{}');
               const localKeys = Object.keys(localVotes);

               const { data: allVotes } = await client.from('caption_votes').select('*').limit(2000);

               voteStats = {};

               if (allVotes) {
                   allVotes.forEach(v => {
                       if (!voteStats[v.caption_id]) voteStats[v.caption_id] = { total: 0, myVote: 0 };
                       if (v.profile_id !== CURRENT_USER_ID) {
                           voteStats[v.caption_id].total += parseInt(v.vote_value);
                       }
                   });
               }

               localKeys.forEach(captionId => {
                   if (!voteStats[captionId]) voteStats[captionId] = { total: 0, myVote: 0 };
                   const myVal = Number(localVotes[captionId]);
                   voteStats[captionId].myVote = myVal;
                   voteStats[captionId].total += myVal;
               });

               allMemes = captions.map(item => ({
                   ...item,
                   imageUrl: imageUrlById[item.image_id] || null,
                   ...extractUploaderIdentity(item)
               }));
               allMemes = applyCommunityMetadata(dedupeMemes(allMemes));

               restoreGeneratedMemes();
               generatedMemes = applyCommunityMetadata(generatedMemes);
               allMemes = applyCommunityMetadata(dedupeMemes([...generatedMemes, ...allMemes]));

               restoreSwipeProgress();
               updateSideTabs();
               updateTopControls();
               renderCurrentView(container);
               setupSearch(container);
           } catch (error) {
               const msg = String(error && error.message ? error.message : error);
               const isLockTimeout = msg.includes('Navigator LockManager') || msg.includes('timed out waiting') || msg.includes('lock:sb-');
               if (isLockTimeout) {
                   console.warn('[Feed] Auth lock timeout, scheduling retry:', msg);
                   FEED_FETCH_QUEUED = true;
                   return;
               }
               logMsg("Error captions: " + msg, "red");
           } finally {
               FEED_FETCH_IN_FLIGHT = false;
               if (FEED_FETCH_QUEUED) {
                   FEED_FETCH_QUEUED = false;
                   setTimeout(() => {
                       refreshFeed(false).catch(err => console.error('[FeedQueue]', err));
                   }, 120);
               }
           }
       }

       function renderCurrentView(container = document.getElementById('content-view')) {
           if (currentView === 'upload') {
               renderUploadView(container);
               return;
           }
           if (currentView === 'account') {
               renderAccountView(container);
               return;
           }
           if (currentView === 'discover') {
               renderDiscoverView(container);
               return;
           }
           if (currentView === 'communities') {
               renderCommunitiesView(container);
               return;
           }
           const memes = getFilteredMemes();
           if (currentView === 'swipe') renderSwipe(memes, container);
           else renderGrid(memes, container);
       }

       function renderUploadView(container) {
           const generatedCount = generatedMemes.length;
           let html = `
               ${renderHeaderActions()}
               <section class="upload-view-panel">
                   <div class="gen-status-panel">
                       <div class="gen-status-row">
                           <span id="gen-status-dot" class="gen-status-dot idle" aria-hidden="true"></span>
                           <span id="gen-status-text">Generation: Waiting for a new upload</span>
                       </div>
                       <div class="gen-status-meta">
                           <span id="gen-model-tag">Model: caption-pipeline-v1</span>
                           <span id="gen-updated-time">Updated: n/a</span>
                       </div>
                   </div>
                   <div class="upload-wrapper">
                       <label class="upload-label" for="image-upload">Upload a New Image</label>
                       <input
                           type="file"
                           id="image-upload"
                           accept="image/jpeg,image/jpg,image/png,image/webp,image/gif,image/heic"
                       >
                       <div id="upload-status" class="upload-status"></div>
                   </div>
               </section>
               <section class="upload-results">
                   <h3 class="upload-results-title">Generated Captions (${generatedCount})</h3>`;

           if (!generatedCount) {
               html += `<p class="upload-empty">Upload an image and fresh caption options will appear here.</p>`;
           } else {
               html += '<ul>';
               generatedMemes.forEach(item => {
                   const fallbackGif = "https://media.giphy.com/media/v1.Y2lkPTc5MGI3NjExM3R6eW55b3R6eW55b3R6eW55/26hkhKd9CQeRv7lqM/giphy.gif";
                   const displayUrl = safeUrl(item.imageUrl, fallbackGif);
                   const safeContent = safePreviewText(item.content);
                   const safeShortId = escapeHtml(String(item.id || '').substring(0, 4));

                   const stats = voteStats[item.id] || { total: 0, myVote: 0 };
                   const upActive = stats.myVote === 1 ? 'active up' : '';
                   const downActive = stats.myVote === -1 ? 'active down' : '';

                   html += `
                   <li id="card-${item.id}">
                       <img src="${displayUrl}" class="meme-image" alt="Meme"
                            onerror="this.onerror=null; this.src='${fallbackGif}';">
                       <div class="card-content">${safeContent}</div>
                       ${renderAIMeta(item)}
                       ${renderCommunityMeta(item)}
                       ${renderUploaderMeta(item)}
                       <div class="actions">
                           <div class="vote-controls">
                               <button class="vote-btn ${upActive} up-btn" onclick="handleVote('${item.id}', 1)">
                                   <i class="fa-solid fa-arrow-up"></i>
                               </button>
                               <span class="vote-count" id="count-${item.id}">${stats.total}</span>
                               <button class="vote-btn ${downActive} down-btn" onclick="handleVote('${item.id}', -1)">
                                   <i class="fa-solid fa-arrow-down"></i>
                               </button>
                           </div>
                           <small style="color:#aaa;">ID: ${safeShortId}</small>
                       </div>
                   </li>`;
               });
               html += '</ul>';
           }

           html += '</section>';
           container.innerHTML = html;
           paintGenerationUIState();
           setupUpload();
       }

       function renderAccountView(container) {
           const ownedUploads = getOwnedUploads();
           const displayName = getCurrentDisplayName();
           const safeEmail = escapeHtml(CURRENT_USER_EMAIL || 'Not available');
           const safeDisplayName = escapeHtml(displayName);
           const safeAccountMessage = ACCOUNT_ACTION_MESSAGE ? escapeHtml(ACCOUNT_ACTION_MESSAGE) : '';
           let html = `
               ${renderHeaderActions(false)}
               <section class="account-panel">
                   <h3 class="account-title">Your Account</h3>
                   <div class="account-row"><strong>Email:</strong> <span>${safeEmail}</span></div>
                   <div class="account-row">
                       <strong>Display name:</strong>
                       <div class="account-name-controls">
                           <input id="display-name-input" class="account-name-input" value="${safeDisplayName}" />
                           <button class="logout-btn" onclick="handleSaveDisplayName()">
                               <i class="fa-solid fa-floppy-disk"></i> Save
                           </button>
                       </div>
                   </div>
                   ${safeAccountMessage ? `<div class="account-message">${safeAccountMessage}</div>` : ''}
               </section>
               <section class="account-panel">
                   <h3 class="account-title">Your Uploads (${ownedUploads.length})</h3>`;

           if (!ownedUploads.length) {
               html += `<p class="upload-empty">No uploads found for this account yet.</p>`;
           } else {
               html += `<div class="account-upload-list">`;
               ownedUploads.forEach(group => {
                   const preview = group.imageUrl || "https://media.giphy.com/media/v1.Y2lkPTc5MGI3NjExM3R6eW55b3R6eW55b3R6eW55/26hkhKd9CQeRv7lqM/giphy.gif";
                   const safePreview = safeUrl(preview, preview);
                   const safeImageId = escapeHtml(group.imageId);
                   html += `
                       <article class="account-upload-item">
                           <img class="account-upload-preview" src="${safePreview}" alt="Upload preview">
                           <div class="account-upload-meta">
                               <div><strong>Image ID:</strong> ${safeImageId}</div>
                               <div><strong>Captions:</strong> ${group.captions.length}</div>
                           </div>
                           <button class="logout-btn danger" onclick="deleteUploadByImageId('${group.imageId}')">
                               <i class="fa-solid fa-trash"></i> Delete Upload
                           </button>
                       </article>`;
               });
               html += `</div>`;
           }
           html += `</section>`;
           container.innerHTML = html;
       }

       function renderDiscoverView(container) {
           let html = `
               ${renderHeaderActions(false)}
               <section class="account-panel">
                   <h3 class="account-title">Find Other Uploaders</h3>
                   <div class="account-name-controls">
                       <input id="uploader-search-input" class="account-name-input" placeholder="Search by Columbia email..." value="${escapeHtml(uploaderSearchTerm)}">
                       <button class="logout-btn" onclick="clearUploaderSearch()">
                           <i class="fa-solid fa-xmark"></i> Clear
                       </button>
                   </div>
                   <div class="account-row" id="uploader-count-label">Showing 0 of 0 uploaders</div>
                   <div id="uploader-directory-container"></div>
               </section>`;
           container.innerHTML = html;
           setupUploaderSearch();
           renderUploaderDirectorySection();
       }

       function renderCommunitiesView(container) {
           const communityOptions = communities
               .map(name => `<option value="${escapeHtml(name)}" ${name === selectedCommunityName ? 'selected' : ''}>${escapeHtml(name)}</option>`)
               .join('');
           const communityChips = communities
               .map(name => `<button class="community-chip ${name === selectedCommunityName ? 'active' : ''}" data-community="${escapeHtml(name)}">${escapeHtml(name)}</button>`)
               .join('');
           const scopedMemes = allMemes.filter(item => getMemeCommunity(item) === selectedCommunityName);

           let html = `
               ${renderHeaderActions(false)}
               <section class="account-panel">
                   <h3 class="account-title">Communities</h3>
                   <div class="account-name-controls">
                       <input id="community-title-input" class="account-name-input" placeholder="Community title (e.g. Campus Dogs)">
                       <button class="logout-btn" id="create-community-btn">
                           <i class="fa-solid fa-plus"></i> Create
                       </button>
                   </div>
                   <div class="community-controls">
                       <label for="community-select">Active community</label>
                       <select id="community-select" class="account-name-input">${communityOptions}</select>
                       <div class="community-chip-row" id="community-chip-row">${communityChips}</div>
                   </div>
                   <div class="upload-wrapper">
                       <label class="upload-label" for="community-image-upload">Upload to ${escapeHtml(selectedCommunityName)}</label>
                       <input type="file" id="community-image-upload" accept="image/jpeg,image/jpg,image/png,image/webp,image/gif,image/heic">
                       <button class="logout-btn" id="community-upload-btn">
                           <i class="fa-solid fa-cloud-arrow-up"></i> Upload to Community
                       </button>
                       <div class="upload-status" id="community-upload-status">${escapeHtml(communityUploadStatus || '')}</div>
                   </div>
                   ${communityCreateMessage ? `<div class="account-message">${escapeHtml(communityCreateMessage)}</div>` : ''}
               </section>
               <section class="account-panel">
                   <h3 class="account-title">${escapeHtml(selectedCommunityName)} Feed (${scopedMemes.length})</h3>`;

           if (!scopedMemes.length) {
               html += `<p class="upload-empty">No uploads in this community yet.</p>`;
           } else {
               html += '<ul>';
               scopedMemes.slice(0, 60).forEach(item => {
                   const fallbackGif = "https://media.giphy.com/media/v1.Y2lkPTc5MGI3NjExM3R6eW55b3R6eW55b3R6eW55/26hkhKd9CQeRv7lqM/giphy.gif";
                   const displayUrl = safeUrl(item.imageUrl, fallbackGif);
                   const safeContent = safePreviewText(item.content);
                   const safeShortId = escapeHtml(String(item.id || '').substring(0, 4));
                   const stats = voteStats[item.id] || { total: 0, myVote: 0 };
                   const upActive = stats.myVote === 1 ? 'active up' : '';
                   const downActive = stats.myVote === -1 ? 'active down' : '';

                   html += `
                       <li id="card-${item.id}">
                           <img src="${displayUrl}" class="meme-image" alt="Meme"
                                onerror="this.onerror=null; this.src='${fallbackGif}';">
                           <div class="card-content">${safeContent}</div>
                           ${renderAIMeta(item)}
                           ${renderCommunityMeta(item)}
                           ${renderUploaderMeta(item)}
                           <div class="actions">
                               <div class="vote-controls">
                                   <button class="vote-btn ${upActive} up-btn" onclick="handleVote('${item.id}', 1)">
                                       <i class="fa-solid fa-arrow-up"></i>
                                   </button>
                                   <span class="vote-count" id="count-${item.id}">${stats.total}</span>
                                   <button class="vote-btn ${downActive} down-btn" onclick="handleVote('${item.id}', -1)">
                                       <i class="fa-solid fa-arrow-down"></i>
                                   </button>
                               </div>
                               <small style="color:#aaa;">ID: ${safeShortId}</small>
                           </div>
                       </li>`;
               });
               html += '</ul>';
           }

           html += '</section>';
           container.innerHTML = html;

           const createBtn = document.getElementById('create-community-btn');
           const selectEl = document.getElementById('community-select');
           const titleInput = document.getElementById('community-title-input');
           const uploadBtn = document.getElementById('community-upload-btn');
           if (createBtn) createBtn.addEventListener('click', handleCreateCommunity);
           if (uploadBtn) uploadBtn.addEventListener('click', handleCommunityUploadClick);
           if (selectEl) selectEl.addEventListener('change', (e) => handleCommunitySelection(e.target.value));
           const chipButtons = document.querySelectorAll('#community-chip-row .community-chip');
           chipButtons.forEach(btn => {
               btn.addEventListener('click', () => handleCommunitySelection(btn.dataset.community || 'General'));
           });
           if (titleInput) {
               titleInput.addEventListener('keydown', (e) => {
                   if (e.key === 'Enter') handleCreateCommunity();
               });
           }
           setupCommunityUploadInput();
       }

       function renderGrid(memes, container) {
           if (memes.length === 0) {
               container.innerHTML = `<p style="text-align:center;">No captions match your current filter.</p>`;
               return;
           }

           let html = `
               ${renderHeaderActions()}
               <ul>`;
          
           memes.forEach(item => {
               const fallbackGif = "https://media.giphy.com/media/v1.Y2lkPTc5MGI3NjExM3R6eW55b3R6eW55b3R6eW55/26hkhKd9CQeRv7lqM/giphy.gif";
               const displayUrl = safeUrl(item.imageUrl, fallbackGif);
               const safeContent = safePreviewText(item.content);
               const safeShortId = escapeHtml(String(item.id || '').substring(0, 4));
              
               const stats = voteStats[item.id] || { total: 0, myVote: 0 };
               const upActive = stats.myVote === 1 ? 'active up' : '';
               const downActive = stats.myVote === -1 ? 'active down' : '';

               html += `
                   <li id="card-${item.id}">
                       <img src="${displayUrl}" class="meme-image" alt="Meme"
                            onerror="this.onerror=null; this.src='${fallbackGif}';">
                      
                       <div class="card-content">${safeContent}</div>
                       ${renderAIMeta(item)}
                       ${renderCommunityMeta(item)}
                       ${renderUploaderMeta(item)}

                       <div class="actions">
                           <div class="vote-controls">
                               <button class="vote-btn ${upActive} up-btn" onclick="handleVote('${item.id}', 1)">
                                   <i class="fa-solid fa-arrow-up"></i>
                               </button>
                              
                               <span class="vote-count" id="count-${item.id}">${stats.total}</span>
                              
                               <button class="vote-btn ${downActive} down-btn" onclick="handleVote('${item.id}', -1)">
                                   <i class="fa-solid fa-arrow-down"></i>
                               </button>
                           </div>
                           <small style="color:#aaa;">ID: ${safeShortId}</small>
                       </div>
                   </li>`;
           });
           container.innerHTML = html + `</ul>`;
       }

       function renderSwipe(memes, container) {
           if (memes.length === 0) {
               container.innerHTML = `<p style="text-align:center;">No captions match your current filter.</p>`;
               return;
           }

           if (swipeIndex < 0) swipeIndex = 0;
           if (swipeIndex >= memes.length) {
               container.innerHTML = `
                   ${renderHeaderActions()}
                   <div class="swipe-panel">
                       <div class="swipe-hint">Deck complete. You rated this whole set.</div>
                       <div class="swipe-end-actions">
                           <button class="logout-btn" onclick="rewindSwipe()">
                               <i class="fa-solid fa-arrow-left"></i> Undo Last Vote
                           </button>
                           <button class="logout-btn" onclick="restartSwipeDeck()">
                               <i class="fa-solid fa-rotate-left"></i> Start Over
                           </button>
                       </div>
                   </div>`;
               return;
           }

           const item = memes[swipeIndex];
           const fallbackGif = "https://media.giphy.com/media/v1.Y2lkPTc5MGI3NjExM3R6eW55b3R6eW55b3R6eW55/26hkhKd9CQeRv7lqM/giphy.gif";
           const displayUrl = safeUrl(item.imageUrl, fallbackGif);
           const safeContent = safePreviewText(item.content);
           const stats = voteStats[item.id] || { total: 0, myVote: 0 };

           container.innerHTML = `
               ${renderHeaderActions()}
               <div class="swipe-panel">
                   <div class="swipe-hint">Left = pass  Right = approve  Swipe also works</div>
                   <div class="swipe-controls">
                       <button class="logout-btn" onclick="rewindSwipe()">
                           <i class="fa-solid fa-arrow-left"></i> Undo Vote
                       </button>
                   </div>
                   <div class="swipe-card" id="swipe-card-${item.id}">
                       <img src="${displayUrl}" class="meme-image" alt="Meme"
                            onerror="this.onerror=null; this.src='${fallbackGif}';">
                       <div class="card-content">${safeContent}</div>
                       ${renderAIMeta(item)}
                       ${renderCommunityMeta(item)}
                       ${renderUploaderMeta(item)}
                       <div class="actions">
                           <div class="vote-controls">
                               <span class="vote-count">${stats.total}</span>
                           </div>
                           <small style="color:#aaa;">${swipeIndex + 1} / ${memes.length}</small>
                       </div>
                   </div>
               </div>`;

           bindSwipeGestures(`swipe-card-${item.id}`);
       }

       function setupSearch(container) {
           const searchInput = document.getElementById('search-input');
           const newSearch = searchInput.cloneNode(true);
           searchInput.parentNode.replaceChild(newSearch, searchInput);
           newSearch.addEventListener('input', (e) => {
               currentSearchTerm = e.target.value.toLowerCase();
               swipeIndex = 0;
               swipeHistory = [];
               if (!currentSearchTerm) saveSwipeProgress();
               renderCurrentView(container);
           });
       }

       async function handleSwipeChoice(voteValue) {
           const memes = getFilteredMemes();
           if (!memes.length || swipeIndex >= memes.length) return;
           const currentMeme = memes[swipeIndex];
           swipeHistory.push(swipeIndex);
           showSwipeFeedback(voteValue);
           handleVote(currentMeme.id, voteValue, true, true).catch(console.error);
           await new Promise(resolve => setTimeout(resolve, 140));
           swipeIndex = swipeIndex + 1;
           saveSwipeProgress();
           renderCurrentView();
       }

       function showSwipeFeedback(voteValue) {
           const card = document.querySelector('.swipe-card');
           if (!card) return;
           card.classList.remove('choice-like', 'choice-dislike');
           card.classList.add(voteValue === 1 ? 'choice-like' : 'choice-dislike');
       }

       function bindSwipeGestures(cardId) {
           const card = document.getElementById(cardId);
           if (!card) return;
           let lastTouchAt = 0;
           let startX = null;

           card.addEventListener('click', (event) => {
               // Ignore synthetic click fired after touchend.
               if (Date.now() - lastTouchAt < 350) return;
               const rect = card.getBoundingClientRect();
               const isRight = (event.clientX - rect.left) > (rect.width / 2);
               handleSwipeChoice(isRight ? 1 : -1);
           });

           card.addEventListener('touchstart', (e) => {
               startX = e.changedTouches[0].clientX;
           }, { passive: true });
           card.addEventListener('touchend', (e) => {
               if (startX == null) return;
               lastTouchAt = Date.now();
               const endX = e.changedTouches[0].clientX;
               const deltaX = endX - startX;
               startX = null;
               if (Math.abs(deltaX) >= 40) {
                   handleSwipeChoice(deltaX > 0 ? 1 : -1);
                   return;
               }
               const rect = card.getBoundingClientRect();
               const touchX = endX - rect.left;
               handleSwipeChoice(touchX > (rect.width / 2) ? 1 : -1);
           }, { passive: true });
       }

       function rewindSwipe() {
           if (!swipeHistory.length) return;
           swipeIndex = swipeHistory.pop();
           saveSwipeProgress();
           renderCurrentView();
       }

       function restartSwipeDeck() {
           swipeIndex = 0;
           swipeHistory = [];
           saveSwipeProgress();
           renderCurrentView();
       }

       async function handleVote(captionId, newValue, suppressGridUI = false, forceSet = false) {
           if (!CURRENT_USER_ID) { alert("Please sign in first."); return; }
           const voteKey = `${CURRENT_USER_ID}:${captionId}`;
           const nowMs = Date.now();
           if (VOTE_COOLDOWNS[voteKey] && (nowMs - VOTE_COOLDOWNS[voteKey] < VOTE_COOLDOWN_MS)) {
               return;
           }
           VOTE_COOLDOWNS[voteKey] = nowMs;

           try {
               const client = getClient();
               const now = new Date().toISOString();
              
               if (!voteStats[captionId]) voteStats[captionId] = { total: 0, myVote: 0 };
               const currentVoteValue = voteStats[captionId].myVote;

               const countSpan = document.getElementById(`count-${captionId}`);
               let currentTotal = countSpan ? (parseInt(countSpan.innerText) || 0) : voteStats[captionId].total;

               let nextVoteValue = 0;
               if (forceSet) {
                   nextVoteValue = newValue;
                   currentTotal = currentTotal + (newValue - currentVoteValue);
                   if (!suppressGridUI) updateUIColors(captionId, newValue);
               } else if (currentVoteValue === newValue) {
                   if (!suppressGridUI) updateUIColors(captionId, 0);
                   currentTotal = currentTotal - newValue;
                   nextVoteValue = 0;
               } else if (currentVoteValue === 0) {
                   if (!suppressGridUI) updateUIColors(captionId, newValue);
                   currentTotal = currentTotal + newValue;
                   nextVoteValue = newValue;
               } else {
                   if (!suppressGridUI) updateUIColors(captionId, newValue);
                   currentTotal = currentTotal + (newValue * 2);
                   nextVoteValue = newValue;
               }

               if (countSpan) countSpan.innerText = currentTotal;

               const localVotes = JSON.parse(localStorage.getItem('my_votes_v1') || '{}');
               if (nextVoteValue === 0) delete localVotes[captionId];
               else localVotes[captionId] = nextVoteValue;
               localStorage.setItem('my_votes_v1', JSON.stringify(localVotes));

               voteStats[captionId].myVote = nextVoteValue;
               voteStats[captionId].total = currentTotal;

               const { error: upsertError } = await client.from('caption_votes').upsert({
                   profile_id: CURRENT_USER_ID,
                   caption_id: captionId,
                   vote_value: nextVoteValue,
                   created_datetime_utc: now,
                   modified_datetime_utc: now
               }, { onConflict: 'profile_id,caption_id' });

               if (upsertError) {
                   await client.from('caption_votes').insert({
                       profile_id: CURRENT_USER_ID,
                       caption_id: captionId,
                       vote_value: nextVoteValue,
                       created_datetime_utc: now
                   });
               }

           } catch (err) {
               console.error(err);
           }
       }

       function updateUIColors(captionId, value) {
           const card = document.getElementById(`card-${captionId}`);
           if (!card) return;
           const upBtn = card.querySelector('.up-btn');
           const downBtn = card.querySelector('.down-btn');
          
           if (upBtn) upBtn.classList.remove('active', 'up');
           if (downBtn) downBtn.classList.remove('active', 'down');

           if (value === 1 && upBtn) upBtn.classList.add('active', 'up');
           if (value === -1 && downBtn) downBtn.classList.add('active', 'down');
       }

       window.addEventListener('resize', applyClientMode, { passive: true });
       window.addEventListener('orientationchange', applyClientMode, { passive: true });

       renderApp()
   </script>
</body>
</html>
